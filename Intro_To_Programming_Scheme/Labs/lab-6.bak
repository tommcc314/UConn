(define (list-at l i)
  (define (list-iter l count)
    (if (= count i) (car l)
        (list-iter (cdr l) (+ count 1))))
  (list-iter l 0))
;(list-at '(3 7 6 2 9 4) 0)
(define (selSort l)
  (define (smallest l)
    (define (smaller a b) (if (< a b) a b))
    (if (null? (cdr l)) (car l)
        (smaller (car l) (smallest (cdr l)))))
  (define (remove v l)
    (if (null? l) l
        (if (equal? v (car l)) (cdr l)
            (cons (car l) (remove v (cdr l))))))
  (if (null? l) '()
      (let* ((first (smallest l))
             (rest (remove first l)))
        (cons first (selSort rest)))))
;(selSort '(3 7 6 2 9 4))
(define (list-median l)
  (define (list-length l)
    (if (null? (cdr l)) 1
        (+ 1 (list-length (cdr l)))))
  (let ((sorted (selSort l))
        (len (list-length l)))
    (if (= (modulo len 2) 0)
        (/ (+ (list-at sorted (/ len 2)) (list-at sorted (- (/ len 2) 1))) 2)
        (list-at sorted (floor (/ len 2))))))
(define (reverse-and-append r-items rest)
    (if (null? r-items) rest
        (reverse-and-append (cdr r-items)
                            (cons (car r-items) rest))))
;(list-median '(3 7 6 2 9 4))
(define (explode x)
  (define (explode-backward x)
    (if (= x 0) '()
       (let ((remaining (explode-backward (floor (/ x 10)))))
         (cons (modulo x 10) remaining))))
  (if (= x 0) '(0)
      (reverse-and-append (explode-backward x) '())))
;(explode 0)
(define (implode l)
  (define (helper l count)
     (if (null? l) 0
         (+ (* (car l) (expt 10 count)) (helper (cdr l) (+ count 1)))))
  (let ((l (reverse-and-append l '())))
    (helper l 0)))
(define (sum-list l)
  (if (null? l) 0
      (+ (car l) (sum-list (cdr l)))))
;(implode '(3 7 6 2 9 4))
(define (has-property x)
  (let* ((x-list (explode x))
         (sum (sum-list x-list))
         (sum-as-list (explode sum))
         (rev-sum (implode (reverse-and-append sum-as-list '()))))
    (= x (* sum rev-sum))))
;(has-property 2)
(define (find sequence test n)
  (define (helper sequence test n count)
    (cond ((< n 0) (sequence (- count 1)))
          ((test (sequence count)) (helper sequence test (- n 1) (+ count 1)))
          (else (helper sequence test n (+ count 1)))))
  (helper sequence test n 0))
(define (fujiwara n)
  (find (lambda (x) x) (lambda (x) (has-property x)) n))
;(fujiwara 4)
