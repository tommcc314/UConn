(define (create-heap v H1 H2)
  (list v H1 H2))
(define (h-root H) (car H))
(define (left H) (cadr H))
(define (right H) (caddr H))
(define (heap-insert f x H)
  (cond ((null? H) (create-heap x '() '()))
        ((f x (h-root H)) (create-heap x (right H) (heap-insert f (h-root H) (left H))))
        (else (create-heap (h-root H) (right H) (heap-insert f x (left H))))))
(define (heap-insert-list f x-list H)
  (if (null? x-list) H
      (heap-insert-list f (cdr x-list) (heap-insert f (car x-list) H))))
(define (combine Ha Hb)
  (cond ((null? Ha) Hb)
        ((null? Hb) Ha)
        (else (create-heap (h-root Ha) Hb (combine (left Ha) (right Ha))))))
(define (empty? H)
  (null? H))
(define (heap-remove f H)
  (if (empty? H) H
      (combine f (left H) (right H))))
(define (heap-insert-root x H)
  (if (null? H) (create-heap x '() '())
      (create-heap x (right H) (heap-insert-root (h-root H) (left H)))))
(define (heap-remove-root H)
  (if (empty? H) H
      (combine (left H) (right H))))
(define (equalize-heaps heap-pair)
  (let ((size1 (caar heap-pair))
        (size2 (cadr heap-pair))
        (heap1 (cdar heap-pair))
        (heap2 (cddr heap-pair)))
  (cond ((< (abs (- size1 size2)) 2) heap-pair)
        ((> (- size1 size2) 1) (equalize-heaps (cons (cons (- size1 1) (heap-remove-root heap1))
                                                     (cons (+ size2 1) (heap-insert-root (car heap1) heap2)))))
        ((> (- size2 size1) 1) (equalize-heaps (cons (cons (+ size1 1) (heap-insert-root (car heap2) heap1))
                                                     (cons (- size2 1) (heap-remove-root heap2))))))))
;(heap-insert-root 6 '(9 (11 () ()) () ()))
;(heap-remove-root '(9 (11 () ()) () ()))
(equalize-heaps (cons (cons 3 '(6 () (9 () (11 () ())))) (cons 1 '(11 () ()))))