(define (merge L1 L2)
  (cond ((and (null? L1) (null? L2)) '())
        ((null? L1) (cons (car L2) (merge L1 (cdr L2))))
        ((null? L2) (cons (car L1) (merge (cdr L1) L2)))
        (else (if (< (car L1) (car L2))
                  (append (list (car L1)) (merge (cdr L1) L2))
                  (append (list (car L2)) (merge L1 (cdr L2)))))))
;(merge '(1 3 4 7 9 12 15) '(2 6 14 17 19))
(define (mergeSort l)
  (define (splitter l L1 L2 count)
    (cond ((null? l) (cons L1 L2))
          ((= (modulo count 2) 0) (splitter (cdr l) (append (list (car l)) L1) L2 (+ count 1)))
          (else (splitter (cdr l) L1 (append (list (car l)) L2) (+ count 1)))))
  (cond ((null? l) (list 0))
        ((null? (cdr l)) (list (car l)))
        (else (merge (mergeSort (car (splitter l '() '() 0))) (mergeSort (cdr (splitter l '() '() 0)))))))
;(mergeSort '(1 6 7 3 9 0 2))
(define (ins x l)
  (define (ins-helper x l inserted)
    (cond ((null? l) '())
          ((and (= x (car l)) (not inserted)) (cons x (ins-helper x (cdr l) #t)))
          ((and (< x (car l)) (not inserted)) (cons x (ins-helper x l #t)))
          (else (cons (car l) (ins-helper x (cdr l) inserted)))))
  (ins-helper x l #f))
;(ins 10 '(1 3 4 7 9 12 15))