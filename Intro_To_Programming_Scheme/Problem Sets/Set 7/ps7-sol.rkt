(define (merge L1 L2)
  (cond ((and (null? L1) (null? L2)) '())
        ((null? L1) (cons (car L2) (merge L1 (cdr L2))))
        ((null? L2) (cons (car L1) (merge (cdr L1) L2)))
        (else (if (< (car L1) (car L2))
                  (append (list (car L1)) (merge (cdr L1) L2))
                  (append (list (car L2)) (merge L1 (cdr L2)))))))
;(merge '(1 3 4 7 9 12 15) '(2 6 14 17 19))
(define (mergeSort l)
  (define (splitter l L1 L2 count)
    (cond ((null? l) (cons L1 L2))
          ((= (modulo count 2) 0) (splitter (cdr l) (append (list (car l)) L1) L2 (+ count 1)))
          (else (splitter (cdr l) L1 (append (list (car l)) L2) (+ count 1)))))
  (cond ((null? l) '())
        ((null? (cdr l)) (list (car l)))
        (else (merge (mergeSort (car (splitter l '() '() 0))) (mergeSort (cdr (splitter l '() '() 0)))))))
;(mergeSort '(1 6 7 3 9 0 2))
;(mergeSort (list 0 9 1 4 2 10 13 3 7 14 -1))
;(mergeSort (list))
;(mergeSort (list 1))
(define (ins x l)
  (define (ins-helper x l inserted)
    (cond ((and (null? l) (not inserted) (list x)))
          ((and (null? l) inserted '()))
          ((and (= x (car l)) (not inserted)) (cons x (ins-helper x (cdr l) #t)))
          ((and (< x (car l)) (not inserted)) (cons x (ins-helper x l #t)))
          (else (cons (car l) (ins-helper x (cdr l) inserted)))))
  (ins-helper x l #f))
;(ins 5 (list 1 2 3 4 6 7))
;(ins 2 (list 1 3 4 5))
;(ins 9 (list 1 2 8))
;(ins 1 (list))
(define (insSort l)
  (define (insAccumulate l new)
    (if (null? l) new
        (insAccumulate (cdr l) (ins (car l) new))))
  (insAccumulate l '()))
;(insSort (list 3 5 1 6 9 0 2 7))
(define (fold-right op initial sequence)
  (if (null? sequence) initial
      (op (car sequence) (fold-right op initial (cdr sequence)))))
;(fold-right + 0 (list 1 2 3 4 5))
;(fold-right cons '() (list 1 2 3 4 5))
(define (fold-left op initial sequence)
  (define (left-list l)
    (if (null? (cdr l)) '()
        (cons (car l) (left-list (cdr l)))))
  (define (last-value l)
    (if (null? (cdr l)) (car l)
        (last-value (cdr l))))
  (if (null? sequence) initial
      (op (fold-left op initial (left-list sequence)) (last-value sequence))))
;(fold-left + 0 (list 1 2 3 4 5))
;(fold-left (lambda (x y) (cons y x)) '() (list 1 2 3 4 5))
(define (my-map p sequence)
  (fold-right (lambda (x y) (cons (p x) y)) '() sequence))
;(my-map (lambda (x) (* x x)) (list 1 2 3 4 5))
(define (my-append seq1 seq2) (fold-right cons seq2 seq1))
;(my-append '(1 3 7 2 5) '(4 0 6 8 9))
(define (my-length sequence) (fold-right (lambda (x y) (+ 1 y)) 0 sequence))
;(my-length '(1 2 3 4 5 6 3))
(define (reverse-r sequence)
  (fold-right (lambda (x y) (append y (list x))) '() sequence))
(define (reverse-l sequence)
  (fold-left (lambda (x y) (cons y x)) '() sequence))
;(reverse-r '(1 2 3 4 5))
;(reverse-l '(1 2 3 4 5))
(define (horner-eval i l)
  (fold-right (lambda (x y) (+ x (* i y))) 0 l))
;(horner-eval 2 (list 1 3 0 5 0 1))
(define (prime? n)
  (define (divisor? k) (= 0 (modulo n k)))
  (define (divisors-upto k)
    (and (> k 1)
         (or (divisor? k) (divisors-upto (- k 1)))))
  (and (> n 1)
       (not (divisors-upto (- n 1)))))
(define (explode x)
  (if (< x 10)
      (list x)
      (append (explode (floor (/ x 10)))
              (list (- x (* 10 (floor (/ x 10))))))))
;(explode 03)
(define (implode l)
  (define (add-digits l place)
    (if (null? l)
        0
        (+ (* (car l) (expt 10 place))
           (add-digits (cdr l) (+ place 1)))))
  (add-digits (reverse l) 0))
(define (left-truncatable-prime? p)
  (let ((p-list (explode p)))
    (cond ((null? (cdr p-list)) (prime? (car p-list)))
          ((memq 0 p-list) #f)
          (else (and (prime? p) (left-truncatable-prime? (implode (cdr p-list))))))))
;(left-truncatable-prime? 107)
(define (right-truncatable-prime? p)
  (define (left-list l)
    (if (null? (cdr l)) '()
        (cons (car l) (left-list (cdr l)))))
  (define (last-value l)
    (if (null? (cdr l)) (car l)
        (last-value (cdr l))))
  (let* ((p-list (explode p))
         (p-last (last-value p-list))
         (p-left (left-list p-list)))
    (cond ((null? (cdr p-list)) (prime? (car p-list)))
          ((memq 0 p-list) #f)
          (else (and (prime? p) (right-truncatable-prime? (implode p-left)))))))
;(right-truncatable-prime? 7393)
;(right-truncatable-prime? 6912950)
;(right-truncatable-prime? 2)
;(right-truncatable-prime? 1)
;(right-truncatable-prime? 1825711)
(define (find sequence test n)
  (define (find-aux x found)
    (let ((fx (sequence x)))
       (if (test fx)
           (if (= (+ found 1) n)
               fx
               (find-aux (+ x 1) (+ found 1)))
           (find-aux (+ x 1) found))))
  (find-aux 1 0))
(define (nth-left-trunc-prime n)
  (find (lambda (x) x) left-truncatable-prime? n))
(nth-left-trunc-prime 5)
(nth-left-trunc-prime 9)
(nth-left-trunc-prime 15)
(nth-left-trunc-prime 17)
(nth-left-trunc-prime 29)
(define (nth-right-trunc-prime n)
  (find (lambda (x) x) right-truncatable-prime? n))
;(nth-right-trunc-prime 15)
(define (two-sided-prime? p)
  (and (left-truncatable-prime? p) (right-truncatable-prime? p)))
(define (nth-two-sided-prime n)
  (find (lambda (x) x) two-sided-prime? n))
;(two-sided-prime? 373)
;(nth-two-sided-prime 10)
;(prime? 1)