; 1a Harmonic Numbers
(define (harmonic n)
  (if (= 1 n) 1
      (+ (/ 1 n) (harmonic (- n 1)))))
;(harmonic 4)
; 1b Euler Estimate
(define (Eulerest n)
  (abs (- (harmonic n) (log n))))
;(Eulerest 100)
; 2 Primality test
(define (prime? n)
  (define (divisor? k) (= 0 (modulo n k)))
  (define (divisors-upto k)
    (and (> k 1)
         (or (divisor? k) (divisors-upto (- k 1)))))
  (and (> n 1)
       (not (divisors-upto (- n 1)))))
; 2 Count Primes
(define (count-primes m)
  (cond ((= m 1) 0)
        ((prime? m) (+ 1 (count-primes (- m 1))))
        (else (count-primes (- m 1)))))
;(count-primes 2)
; 3 Relatively Prime
(define (rel-prime a b)
  (define (divides-both d)
    (and (= 0 (modulo a d))
         (= 0 (modulo b d))))
  (define (divisor-upto k)
    (and (> k 1)
         (or (divides-both k)
             (divisor-upto (- k 1)))))
  (not (divisor-upto (min a b))))
;(rel-prime 2 2)
; 3 Count Relative Primes
(define (count-rel-prime n)
  (define (rel-prime-check a bound)
  (define (sub-count a b)
    (cond ((= b 1) 1)
          ((rel-prime a b) (+ 1 (sub-count a (- b 1))))
          (else (sub-count a (- b 1)))))
  (if (= a 1) bound
      (+ (sub-count a bound) (rel-prime-check (- a 1) bound))))
  (ceiling (/ (rel-prime-check n n) 2)))
;(count-rel-prime 1)
; 4a Lucas Numbers
(define (lucas n)
  (cond ((= n 0) 2)
        ((= n 1) 1)
        (else (+ (lucas (- n 1)) (lucas (- n 2))))))
;(lucas 3)
(define (fibonacci n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fibonacci (- n 1)) (fibonacci (- n 2))))))
;(fibonacci 6)
; 4b Lucas Number Ratios
(define (Lucas-ratio n)
  (+ 0.0 (/ (lucas n) (lucas (- n 1)))))
;(Lucas-ratio 30)
(define (Fibonacci-ratio n)
  (+ 0.0 (/ (fibonacci n) (fibonacci (- n 1)))))
;(Fibonacci-ratio 30)
; 4c
;; This function represents the table shown in the PDF.
;; Simply "hard-code" the number of recursive call you believe
;; take place for inputs 3 through 6
(define (rec-call-lucas k)
    (cond ((= k 1)  0)
          ((= k 2)  2)
          ((= k 3)  4)
          ((= k 4)  8)
          ((= k 5)  14)
          ((= k 6)  24)
    ))
;; Do the same for the fast-lucas-helper
(define (rec-call-fast-lucas-helper k)
    (cond ((= k 1)  0)
          ((= k 2)  1)
          ((= k 3)  2)
          ((= k 4)  3)
          ((= k 5)  4)
          ((= k 6)  5)
    ))
; 5a Golden Ratio by continued fractions
(define (golden n)
  (if (= n 1) 2
      (+ 1 (/ 1 (golden (- n 1))))))
;(golden 10)
; 5b Golden Ratio by continued square root
(define (golden-sqrt n)
  (if (= n 0) 1
      (sqrt (+ 1 (golden-sqrt (- n 1))))))
;(golden-sqrt 10)
; 6 explain
(define (explain-interval-sum)
  (define a "One can never do  an induction on both inputs at once.")
  (define b "The base case isn't quite right. It needs to be updated to account for the two inductive calls.")
  (define c "The inductive case should be adding three things together.")
  (define d "The predicate to recognize the base case is wrong. One can go from m > n to m < n without ever seeing n = m.")
  (define e "I have no idea.")
  d)
; 7 Ackermann Function
(define (ack m n)
  (cond ((= m 0) (+ n 1))
        ((and (> m 0) (= n 0)) (ack (- m 1) 1))
        ((and (> m 0) (> n 0)) (ack (- m 1) (ack m (- n 1))))))
;(ack 4 0)
; 8 Catalan numbers
(define (catalan n)
  (define (factorial x)
  (define (fact-iter a product)
	(if (= a 0)
		product
		(fact-iter (- a 1) (* product a))))
  (fact-iter x 1))
  (/ (factorial (* 2 n)) (* (factorial (+ 1 n)) (factorial n))))
;(catalan 8)
; 9 pi-approx
(define (square x) (* x x))
(define pi-approx 
  (let ((a (/ (+ 23 (* 4 (sqrt 34))) 2))
       (b (/ (+ (* 19 (sqrt 2)) (* 7 (sqrt 17))) 2))
       (c (+ 429 (* 304 (sqrt 2))))
       (d (/ (+ 627 (* 442 (sqrt 2))) 2)))
       (let ((u (* (square (+ a (sqrt (- (square a) 1))))
             (square (+ b (sqrt (- (square b) 1))))
             (+ c (sqrt (- (square c) 1)))
             (+ d (sqrt (- (square d) 1))))))
         (/ (log (+ (expt (* 2 u) 6) 24)) (sqrt 3502)))))
;pi-approx
; 10 Gauss-Legendre
(define (gauss-legendre tol)
  (define (check-tol a b tol)
    (<= (abs (- a b)) tol))
  (define (gauss-legendre-iter a b t p tol)
    (define a1 (/ (+ a b) 2))
    (define b1 (sqrt (* a b)))
    (define t1 (- t (* p (expt (- a (/ (+ a b) 2)) 2))))
    (define p1 (* 2 p))
    (if (check-tol a b tol)
        (/ (expt (+ a b) 2) (* 4 t))
        (gauss-legendre-iter a1 b1 t1 p1 tol)))
  (gauss-legendre-iter 1 (/ 1 (sqrt 2)) (/ 1 4) 1 tol))
;(gauss-legendre 0.00000001)