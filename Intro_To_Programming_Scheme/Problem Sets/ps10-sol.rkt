(define (make-clock h m)
  (let ((time (+ (* h 60) m)))
    (define (two-digits t)
      (if (= (string-length (number->string t)) 2) (number->string t)
          (string-append "0" (number->string t))))
    (define (get-time)
      (let ((reg-hour (cond ((< time 60) 12)
                            ((< time 780) (floor (/ time 60)))
                            (else (floor (/ (- time 720) 60)))))
            (am-pm (cond ((< time 720) "AM")
                         (else "PM"))))
        (string-append (number->string reg-hour) ":" (two-digits (modulo time 60)) " " am-pm "\n")))
    (define (get-mil)
      (string-append (two-digits (floor (/ time 60))) ":" (two-digits (modulo time 60)) "\n"))
    (define (tick)
      (begin (set! time (+ time 1))
             (cond ((> time 1439) (set! time (modulo time 1440))))))
    (lambda (method)
      (cond ((eq? method 'time) get-time)
            ((eq? method 'military) get-mil)
            ((eq? method 'tick) tick)))))
(define clock1 (make-clock 21 0))
((clock1 'time))
((clock1 'military))
((clock1 'tick))
((clock1 'time))
(define clock2 (make-clock 23 59))
((clock2 'tick))
((clock2 'military))
((clock2 'tick))
((clock2 'tick))
((clock2 'time))
((clock2 'military))
(define (make-stack)
  (let ((stack '()))
    (define (empty?) (null? stack))
    (define (push x) (set! stack (cons x stack)))
    (define (pop) (begin (car stack) (set! stack (cdr stack))))
    (define (top) (car stack))
    (define (dispatcher method)
      (cond ((eq? method 'empty?) empty?)
            ((eq? method 'push) push)
            ((eq? method 'pop) pop)
            ((eq? method 'top) top)))
    dispatcher))
;(define mystack (make-stack))
;((mystack 'push) 5)
;(display ((mystack 'pop)))
;(define mystack (make-stack))
;((mystack 'empty?))
(define (eval-postfix p)
  (define (helper p stack)
    (define (evaluate op)
      (let ((n2 ((stack 'top)))
            (del1 ((stack 'pop)))
            (n1 ((stack 'top)))
            (del2 ((stack 'pop))))
        (cond ((equal? op #\+) ((stack 'push) (+ n1 n2)))
              ((equal? op #\-) ((stack 'push) (- n1 n2)))
              ((equal? op #\*) ((stack 'push) (* n1 n2)))
              ((equal? op #\/) ((stack 'push) (/ n1 n2)))
              ((equal? op #\^) ((stack 'push) (expt n1 n2))))))
    (cond ((null? p) ((stack 'top)))
          ((number? (car p)) (begin ((stack 'push) (car p)) (helper (cdr p) stack)))
          (else (begin (evaluate (car p)) (helper (cdr p) stack)))))
  (define stack (make-stack))
  (helper p stack))
;(eval-postfix (list 23 15 #\+))
(define (dfs T)
  (define (helper stack)
    (if ((stack 'empty?)) '()
        (let* ((node ((stack 'top)))
               (left (cadr node))
               (right (if (null? left) '() (caddr node))))
          (begin ((stack 'pop))
                 (if (not (null? right)) ((stack 'push) right))
                 (if (not (null? left)) ((stack 'push) left))
                 (if (number? (car node)) (cons (car node) (helper stack))
                     (helper stack))))))
  (define stack (make-stack))
  ((stack 'push) T)
  (helper stack))
;(dfs '(1 (2 (3 '() '()) (4 '() '())) (5 (6 (7 '() '()) (8 '() '())) (9 '() '()))))
(define (make-queue)
  (let ((queue '()))
    (define (empty?) (null? queue))
    (define (enqueue x) (set! queue (append queue (list x))))
    (define (dequeue) (begin (car queue) (set! queue (cdr queue))))
    (define (top) (car queue))
    (define (dispatcher method)
      (cond ((eq? method 'empty?) empty?)
            ((eq? method 'enqueue) enqueue)
            ((eq? method 'dequeue) dequeue)
            ((eq? method 'top) top)))
    dispatcher))
;(define my-queue (make-queue))
;((my-queue 'empty?))
;((my-queue 'enqueue) 2)
;((my-queue 'enqueue) 3)
;((my-queue 'top))
;((my-queue 'dequeue))
;((my-queue 'top))
(define (bfs T)
  (define (helper queue)
    (if ((queue 'empty?)) '()
        (let* ((node ((queue 'top)))
               (left (cadr node))
               (right (if (null? left) '() (caddr node))))
          (begin ((queue 'dequeue)) 
                 (if (not (null? left)) ((queue 'enqueue) left))
                 (if (not (null? right)) ((queue 'enqueue) right))
                 (if (number? (car node)) (cons (car node) (helper queue))
                     (helper queue))))))
  (define queue (make-queue))
  ((queue 'enqueue) T)
  (helper queue))
;(bfs '(1 (2 (3 '() '()) (4 '() '())) (5 (6 (7 '() '()) (8 '() '())) (9 '() '()))))
