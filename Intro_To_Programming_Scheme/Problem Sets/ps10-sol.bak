(define (make-clock h m)
  (let ((time (+ (* h 60) m)))
    (define (two-digits t)
      (if (= (string-length (number->string t)) 2) (number->string t)
          (string-append "0" (number->string t))))
    (define (get-time)
      (let ((reg-hour (cond ((< time 60) 12)
                            ((< time 780) (floor (/ time 60)))
                            (else (floor (/ (- time 720) 60)))))
            (am-pm (cond ((< time 720) "AM")
                         (else "PM"))))
        (string-append (number->string reg-hour) ":" (two-digits (modulo time 60)) " " am-pm "\n")))
    (define (get-mil)
      (string-append (two-digits (floor (/ time 60))) ":" (two-digits (modulo time 60)) "\n"))
    (define (tick)
      (begin (set! time (+ time 1))
             (cond ((> time 1439) (set! time (modulo time 1440))))))
    (lambda (method)
      (cond ((eq? method 'time) get-time)
            ((eq? method 'military) get-mil)
            ((eq? method 'tick) tick)))))
;(define clock (make-clock 2 0))
;((clock 'time))
;((clock 'military))
;((clock 'tick))
;((clock 'time))
;((clock 'military))
(define (make-stack)
  (let ((stack '()))
    (define (empty?) (null? stack))
    (define (push x) (set! stack (cons x stack)))
    (define (pop) (begin (car stack) (set! stack (cdr stack))))
    (define (top) (car stack))
    (define (dispatcher method)
      (cond ((eq? method 'empty?) empty?)
            ((eq? method 'push) push)
            ((eq? method 'pop) pop)
            ((eq? method 'top) top)))
    dispatcher))
;(define mystack (make-stack))
;((mystack 'push) 5)
;(display ((mystack 'pop)))
(define (eval-postfix p)
  (define (helper p stack)
    (define (evaluate op)
      (let ((n2 ((stack 'top)))
            (del1 ((stack 'pop)))
            (n1 ((stack 'top)))
            (del2 ((stack 'pop))))
        (cond ((equal? op #\+) ((stack 'push) (+ n1 n2)))
              ((equal? op #\-) ((stack 'push) (- n1 n2)))
              ((equal? op #\*) ((stack 'push) (* n1 n2)))
              ((equal? op #\/) ((stack 'push) (/ n1 n2)))
              ((equal? op #\^) ((stack 'push) (expt n1 n2))))))
    (cond ((null? p) ((stack 'top)))
          ((number? (car p)) (begin ((stack 'push) (car p)) (helper (cdr p) stack)))
          (else (begin (evaluate (car p)) (helper (cdr p) stack)))))
  (define stack (make-stack))
  (helper p stack))
;(eval-postfix (list 23 15 #\+))
