(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accumulate combiner null-value term (next a) next b))))
(define (sum term a next b)
  (accumulate + 0 term a next b))
(define (product term a next b)
  (accumulate * 1 term a next b))
(define (catalan n)
  (define (factorial n)
    (if (= n 0) 1
        (* n (factorial (- n 1)))))
  (accumulate + 0 (lambda (x) (/ (factorial (* 2 n))
                                 (* (factorial (+ n 1)) (factorial n))))
              n (lambda (x) (+ x 1)) n))
;(catalan 9)
(define (leibniz-pi n)
  (* 4 (accumulate + 0 (lambda (x) (- (* (expt (- 1) x)
                                 (/ 1 (- (* 2 x) 1)))))
              1 (lambda (x) (+ x 1)) n)))
;(leibniz-pi 30)
(define (accumulate-tr combiner null-value term a next b)
  (define (tr-iter combiner term a next b total)
    (if (> a b)
        total
        (tr-iter combiner term (next a) next b (combiner (term a) total))))
  (tr-iter combiner term a next b null-value))
(define (fact n)
  (accumulate-tr * 1
                 (lambda (x) (if (= x 0) 1 x)) 0 (lambda (x) (+ x 1)) n))
;(fact 5)
(define (e-to-x x n)
  (accumulate-tr + 0 (lambda (n) (if (= x 0) 1 (/ (expt x n) (fact n))))
                 0 (lambda (n) (+ n 1)) n))
;(e-to-x 8 20)
(define (encode p)
  (let ((x (car p))
        (y (cdr p)))
    (if (= x (max x y)) (+ (* x x) x y) (+ (* y y) x))))
;(encode (cons 4 5))
(define (decode z)
  (let ((f (floor (sqrt z))))
    (if (< (- z (* f f)) f) (cons (- z (* f f)) f)
        (cons f (- z (* f f) f)))))
;(decode 34)
(define (sub-complex c d)
  (cons (- (car c) (car d)) (- (cdr c) (cdr d))))
;(sub-complex (cons 5 6) (cons 9 1))
(define (div-complex c d)
  (let ((a (car c))
        (b (cdr c))
        (c (car d))
        (d (cdr d)))
    (cons (/ (+ (* a c) (* b d)) (+ (* c c) (* d d)))
          (/ (- (* b c) (* a d)) (+ (* c c) (* d d))))))
(define (sum-quadratic-roots a b c)
  (let ((a (if (and (pair? b) (not (pair? a))) (cons a 0) a))
        (b (if (and (pair? a) (not (pair? b))) (cons b 0) b)))
    (if (or (pair? a) (pair? b)) (cons (- (car (div-complex b a))) (- (cdr (div-complex b a)))) (- (/ b a)))))
(define (prod-quadratic-roots a b c)
  (let ((a (if (and (pair? c) (not (pair? a))) (cons a 0) a))
        (c (if (and (pair? a) (not (pair? c))) (cons c 0) c)))
    (if (or (pair? a) (pair? c)) (div-complex c a) (/ c a))))
(define (sum-cubic-roots a b c d)
  (let ((a (if (and (pair? b) (not (pair? a))) (cons a 0) a))
        (b (if (and (pair? a) (not (pair? b))) (cons b 0) b)))
    (if (or (pair? a) (pair? b)) (cons (- (car (div-complex b a))) (- (cdr (div-complex b a)))) (- (/ b a)))))
(define (sum-pairs-cubic-roots a b c d)
  (let ((a (if (and (pair? c) (not (pair? a))) (cons a 0) a))
        (c (if (and (pair? a) (not (pair? c))) (cons c 0) c)))
    (if (or (pair? a) (pair? c)) (div-complex c a) (/ c a))))
(define (prod-cubic-roots a b c d)
  (let ((a (if (and (pair? b) (not (pair? a))) (cons a 0) a))
        (d (if (and (pair? a) (not (pair? d))) (cons d 0) d)))
    (if (or (pair? a) (pair? b)) (cons (- (car (div-complex d a))) (- (cdr (div-complex d a)))) (- (/ d a)))))
