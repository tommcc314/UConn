#include "buffer.h"
#include <stdio.h>
#include <pthread.h>
#include <time.h>
#include <stdlib.h>

typedef struct SData {
   SBuffer* sb;
   pthread_mutex_t mtx;
   /*
    * Add condition variables required
   */
   pthread_cond_t bufferNotEmpty;
   pthread_cond_t bufferNotFull;
} SData;

void *consumer(void* consumer_thread_data);
void *producer(void *producer_thread_data);

int main(int argc,char* argv[])
{
   srand(time(NULL));
   int status;
   SData shared;
   shared.sb = makeBuffer(32);
   pthread_t prod1, cons1, cons2, cons3;
   /* TODO
      * Initialize mutexes and condition variables
      * Setup 4 threads. 1 producer and 3 consumers.
      * Make the producer generate "tasks" to compute factorial
      * Make the consumers retrieve task and do them (and print on stdout)
   */
   pthread_mutex_init(&shared.mtx, NULL);
   pthread_cond_init(&shared.bufferNotEmpty, NULL);
   pthread_cond_init(&shared.bufferNotFull, NULL);
   status = pthread_create(&prod1, NULL, (void *(*)(void *))producer, (void *) &shared);
   status = pthread_create(&cons1, NULL, (void *(*)(void *))consumer, (void *) &shared);
   status = pthread_create(&cons2, NULL, (void *(*)(void *))consumer, (void *) &shared);
   status = pthread_create(&cons3, NULL, (void *(*)(void *))consumer, (void *) &shared);
   void* p1, *c1, *c2, *c3;
   pthread_join(prod1, &p1), pthread_join(cons1, &c1), pthread_join(cons2, &c2), pthread_join(cons3, &c3);
   pthread_mutex_destroy(&shared.mtx);
   pthread_cond_destroy(&shared.bufferNotEmpty), pthread_cond_destroy(&shared.bufferNotFull);
   return 0;
}

long long fact(long long n) {
   if (n==0)
      return 1;
   else return n * fact(n-1);
}

void *producer(void *producer_thread_data) {
   //TODO
   // the producer should produce 10000 tasks - computation of fact of random numbers between 0-15
   // once done, the producer should compute fact of -1 thrice to terminate each of the consumers
   // producer should, therefore, terminate after generating 10000 + 3 tasks
   SData* shared = producer_thread_data;
   for (int i = 0; i < 10000; ++i) {
      int num = rand() % 16;
      Task t;
      t.query = num;
      pthread_mutex_lock(&shared->mtx);
      while (shared->sb->nb == shared->sb->sz) {
         pthread_cond_wait(&shared->bufferNotFull, &shared->mtx);
      }
      bufferEnQueue(shared->sb, t);
      pthread_cond_signal(&shared->bufferNotEmpty);
      pthread_mutex_unlock(&shared->mtx);
   }
   for (int i = 0; i < 3; ++i) {
      Task t;
      t.query = -1;
      pthread_mutex_lock(&shared->mtx);
      while (shared->sb->nb == shared->sb->sz) {
         pthread_cond_wait(&shared->bufferNotFull, &shared->mtx);
      }
      bufferEnQueue(shared->sb, t);
      pthread_cond_signal(&shared->bufferNotEmpty);
      pthread_mutex_unlock(&shared->mtx);
   }
}

void *consumer(void* consumer_thread_data) {
   SData* shared = consumer_thread_data;
   //TODO
   // the consumer should compute factorials of the tasks generated by the producer.
   // if the number read is -1, the consumer should terminate.
   while (1) {
      pthread_mutex_lock(&shared->mtx);
      while (shared->sb->nb == 0) {
         pthread_cond_wait(&shared->bufferNotEmpty, &shared->mtx);
      }
      Task t = bufferDeQueue(shared->sb);
      pthread_cond_signal(&shared->bufferNotFull);
      pthread_mutex_unlock(&shared->mtx);
      if (t.query == -1) break;
      printf("%lld ", fact(t.query));
   }
}